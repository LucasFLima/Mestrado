\chapter{CONTRATOS REST COM DESIGN-BY-CONTRACT}


\section{PROPOSTA: SERVIÇOS COM DESIGN-BY-CONTRACT}
\label{PropostaServicoDbC}
\vspace{-6mm}

Os benefícios esperados pela adoção da arquitetura orientada a serviços
somente serão auferidos com a concepção adequada de cada serviço. 
Por essa razão, é necessário planejar o projeto dos serviços criteriosamente
antes de lançar mão do desenvolvimento, com preocupação especial em garantir
um nível aceitável de estabilidade aos consumidores de cada serviço.
Nessa etapa do projeto de desenho da solução, a especificação do contrato do
serviço (Web API) exerce uma função fundamental. 

Na sociedade civil, contratos são meios de se formalizar acordo entre partes a
fim de definir os direitos e deveres de cada parte e buscar atingir o
objetivo esperado dentro de determinadas regras. Cada parte espera que as outras
cumpram com suas obrigações.
Por outro lado, sabe-se que o descumprimeto das obrigações costuma implicar de
penalizações até o desfazimento do contrato. 

Contratos entre serviços Web seguem em uma linha análoga. O desenho das
capacidades (operações) e dos dados das mensagens correspondem aos
termos do contrato no sentido do que o consumidor deve esperar do serviço
provedor. Porém identificou-se, após ampla pesquisa realizada sobre o tema, que
as linguagens disponíves para especificação de contratos atingem apenas esse
nível de garantias. No contexto de webservices em REST, conforme descrito na
seção \ref{secaoREST}, há ainda a ausência de padrão para especificação
contratos.

A proposta deste trabalho é extender os níveis de garantias, de modo a promover
um patamar adicional com obrigações mutuas entre os serviços (consumidor e
provedor). Isso se dá para adoção do conceito de \designbycontract{} (debatido
na seção \ref{Design-by-Contract}) em que a execução da
capacidade do serviço garantirá a execução, desde que satisfeitas as condições
prévias. As próximas subseções detalham o modo de operação dos serviços com as
construções de \designbycontract{}.

\vspace{-6mm}

\subsection{Modelo de operação}
\vspace{-6mm}

As garantias para execução dos serviços são estabelecidas em duas etapas: pré e
póscondições. Nas precondições o provedor do serviço estabelece os requisitos
para que o serviço possa ser executado pelo cliente. A etapa de pós-condições
tem o papel de validar se a mensagem de retorno do serviço possui os resultados
esperados.

O diagrama da Figura \ref{FigServiceDbC} descreve como ocorre a operação das
pré e pós-condições. O processo se inicia com a chamada à capacidade do serviço e a
identificação da existência de uma precondição. Caso tenham sido estabelecidas 
precondições, essas são avaliadas. Caso alguma delas não tenham sido
satisfeitas, o serviço principal não é processado e o provedor do serviço
retornar o código de falha definido no contrato correspondente.


\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm 0mm,clip]{ServiceDbC.png}
\caption{Digrama de atividades com verificação de pré e pós condições}
\label{FigServiceDbC}
\end{figure}

Caso tenham sido definidas pós-condições, essas são acionadas após o
processamento da capacidade, porém antes do retorno ao consumidor do serviço.
Assim, conforme Figura \ref{FigServiceDbC}, visando não entregar ao cliente uma
mensagem ou situação incoerente, as pós-condições são validadas. Caso todas as
pós-condições tenham sido satisfeitas, a mensagem de retorno é encaminhada ao
cliente. Caso contrário, será retornado o código de falha definido para a
pós-condição violada.

\subsubsection{Observação sobre invariantes}
\vspace{-6mm}

Em \designbycontract{}, além dos conceitos de pré e pós-condições,
há também a ideia de invariantes\cite{meyer1997object}. Quando aplicadas a uma classe na
orientação a objetos, as invariantes estabelecem restrições sobre o estado
armazenado nos objetos instanciados dessa classe. No contexto de orientação a
serviços, tem-se por princípio a ausência de estados dos serviços, descrito na
seção \ref{PrincipiosSOA}. Por essa razão, no estudo sobre a incorporação de
\designbycontract{} em contratos de serviços, as invariantes não foram
consideradas.


\subsection{Verificação das precondições}
\vspace{-6mm}

As precondições podem ser do tipo baseado nos parâmetros da requisição ou do
tipo baseado na chamada a outro serviço. Denomina-se, no contexto desta
dissertação, de básica a precondição baseada apenas nos parâmetros da
requisição (atributos da chamada ao serviço). Essa validação é direta,
comparando os valores passados com os valores admitidos. 

No caso das precondições baseadas em serviços, é realizada chamada a outro
serviço para verificar se uma determinada condição é satisfeita. Este modo de
funcionamento, que se assemelha a uma composição de serviço, é mais versátil, pois permite
validações de condições complexas sem que a lógica associada seja conhecida pelo
cliente. Assim, os contratos que estabelecem esse tipo de
precondição se mantem simples.

A Figura \ref{FigServicePrecondition} detalha as etapas de verificação de cada
precondição. Nota-se que a saída para as situações de desatendimento às
precondições, independentemente do tipo, é o mesmo. O objetivo desta abordagem
é simplificar o tratametno de exceção no consumidor.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm
0mm,clip]{img/PreconditionValidation.png}
\caption{Diagrama de atividades do processamento da precondição}
\label{FigServicePrecondition}
\end{figure}


\subsection{Verificação das pós-condições}
\vspace{-6mm}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm
0mm,clip]{img/PostconditionValidation.png} 
\vspace{-6mm}
\caption{Diagrama de atividades do processamento da pós-condição}
\label{FigServicePostcondition}
\end{figure}

A verificação das pós-condições acontece de modo muito similar a das
precondições. Há também os dois tipos, baseado em valores e em chamadas a
outros serviços. O diferencial está em que a validação dos valores passa a
ocorrer a partir dos valores contidos na mensagem de retorno. A Figura
\ref{FigServicePostcondition} descreve as etapas necessárias para validação de
cada precondição.


\section{EXTENSÃO DA NEOIDL PARA DESIGN BY CONTRACT}
\label{extensaoNeoIDL-DbC}

A sintaxe escolhida para possibilitar a especificação de pré e pós condições
na \neoidl{} foi influenciada por três linguagens e extensões de linguagens de
programação: Eiffel, JML e Spec\# (exemplificadas na subseção
\ref{implementDbC}). 

Em Eiffel, as asserções são expressões booleanas, de modo que uma pré e uma
poscondição podem ter resultado verdadeiro ou falso. As asserções também podem
incluir chamadas a funções, extendendo a validações a lógicas mais sofisticadas
\cite{meyer1992applying}. Essas caracteríticas, por serem simples e versáteis,
foram consideradas adequadas e incorporadas à especificação de
\designbycontract{} em contratos de serviços na \neoidl{}.

A primeira sintaxe de \designbycontract{} na \neoidl{} teve como
base a sintaxe da JML, especialmente em como se associar as pré e poscondições a
cada serviço ou capacidade, assemelhando-se a comentários e iniciados pelo
símbolo de arroba (@). A figura \ref{lst:precondicaoJML-neo} apresenta um
exemplo de especificação de precondição seguindo a linha da JML.

\vspace{6mm}

\begin{figure}[h]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{trechos_codigo/DBCsimple.neo}
\vspace{-.5cm}
\end{small} 
\caption{Forma preliminar de precondição na \neoidl}
\label{lst:precondicaoJML-neo}
\end{figure}

Essa forma foi apresentada no Workshop de Teses e Dissertações do CBSoft em 2015
\cite{lima2015contratos}, ainda nos primeiros estágios do trabalho. Os revisores
apontaram dificuldade de distinguir, na especificação, entre as pré e
poscondições e as capacidades, pois possuiam prefixos muito
semelhantes (ver linhas 6 a 8).
Essas críticas impulsionaram a busca por outra sintaxe mais adequada aos elementos textuais já
existentes na \neoidl{}.

Spec\# possui uma forma de especificação de asserções em que as pré e
poscondições são declaradas logo após a assinatura do método ou classe, apenas
com o uso das palavras reservadas \emph{require} e \emph{ensure}, sem uso de
símbolos. Essa abordagem foi aplicada à \neoidl{} para versão final da sintaxe
com suporte a \designbycontract{}.

As próximas subseções apresentam alguns exemplos de especificação de pre e
poscondições na \neoidl{} e as mudanças introduzidas na sintaxe da linguagem.
Inicialmente as condições de \designbycontract{} são demonstradas separadamente
e, ao final, a subseção \ref{SintaxeGeralDbc} consolida o conjunto
de novos elementos sintáticos e como eles são estruturados.


\subsection{Precondição básica}
\label{precondicaoBasica}

Uma precondição básica é a que valida os valores recebidos na
requisição, comparando-os com os valores estabelecidos na instrução
\emph{require} do contrato. Esse tipo de precondição assemelha-se a validação
dos atributos recebidos por um método no paradigma de orientação a objetos. A origem das
informações, isto é, onde os valores que serão validados se encontram, depende
da operação HTTP utilizada. A subseção \ref{FonteDadosDbc} descreve como esses
dados são obtidos.

A \neoidl{} admite seis operadores de comparação: igualdade (\literal{==}),
diferença (\literal{<>}), maior (\literal{>}), maior ou igual (\literal{>=}),
menor (\literal{<}) e menor ou igual (\literal{<=}). Eles podem ser aplicados a
qualquer tipo de pré ou poscondição.

A Figura \ref{lst:DBCPreCondBasica} (linhas 7 e 8) apresenta um exemplo de
precondição básica em uma forma simples, em que apenas um valor é testado (id)
e, caso a condição não seja satisfeita, a instrução \emph{otherwise} indica o
valor a ser retornado (código HTTP Not Found).  	

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{trechos_codigo/store_pre_basica.neo}
\end{small}
\caption{Exemplo de notação de precondição básica na \neoidl{}}
\label{lst:DBCPreCondBasica}
\end{figure} 

As precondições básicas admitem algums combinações com os operadores \emph{not},
\emph{and} e \emph{or}, permitindo estabelecer regras mais flexíveis. Por
exemplo, a precondição apresentada na Figura \ref{lst:DBCPreCondBasica} poderia
ser escrita como \emph{\textbf{require} (\textbf{not} id \literal{<=} 0)}. Os
operadores \emph{and} e \emph{or} são infixos (ex.: \emph{\textbf{require}
((id \literal{>} 0 \textbf{or} id \literal{<=} -1000))}). O uso do operador
\emph{and} produz o mesmo efeito de se declarar duas precondições.



\subsection{Pós-condição básica}

Em termos sintáticos, as pós-condições básicas possuem uma forma muito
semelhante às precondições básicas (\ref{precondicaoBasica}), diferindo-se
exclusivamente pelo uso da instrução \emph{ensure}. A Figura
\ref{lst:DBCPosCondBasica} (linhas 8 e 9) mostra um exemplo de pós-condição
básica em que, após a execução da operação \emph{get}, se o valor do atributo \emph{quantity} não
for maior que zero, então o serviço não foi executado adequadamente e a exceção
(\emph{otherwise}) é retornada.

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{trechos_codigo/store_pos_basica.neo}
\end{small}
\caption{Exemplo de notação de pós-condição básica na \neoidl{}}
\label{lst:DBCPosCondBasica}
\end{figure} 


\subsection{Precondição com chamada a serviço}

As precondições baseadas em serviços seguem uma sequência que envolve a chamada
a outro serviço antes do processamento do serviço principal, em um tipo simples de
composição de serviço. Essa abordagem permite que precondições complexas sejam
validadas por serviços especializados, sem que a especificação do contrato
de serviço seja complexa. Essa proposta preserva ainda a ideia original de
Eiffel\cite{meyer1988eiffel}, de que pré e pós-condições sejam expressões
\emph{booleanas}.

A primeira etapa do processo de execução da precondição de serviço consiste em
fazer a chamada a um serviço (ver Figura \ref{FigServicePrecondition}) por meio de uma
operação \emph{GET}. Em seguida, o código de \textit{status} retornado pelo
serviço da precondição é comparado com o valor especificado na precondição do contrato.

Após o acionamento do serviço da precondição, o comportamento é mesmo da
precondição básica (ver \ref{precondicaoBasica}). Caso a precondição seja
satisfeita, é retornado o valor indicado pela instrução \emph{otherwise}. As
precondições de serviço na \neoidl{} admitem os mesmos operadores de comparação
que as precondições básicas.

A Figura \ref{lst:DBCPreCondServico} ilustra a especificação de uma precondição
do tipo serviço (linhas 8 e 9). Assim, antes de executar a operação \emph{POST}
do serviço principal, o serviço \emph{store.getOrder} é acionado. Caso esse
serviço retorno o código correspondente a \emph{HTTP Not Found}, a operação
\emph{POST} é executada. Caso contrário, o serviço principal retorna o valor
correspondente a \emph{HTTP Invalid Precondition}, em razão do estabelecido no
\emph{otherwise}.


\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{trechos_codigo/store_pre_servico.neo}
\end{small}
\caption{Exemplo de notação de precondição com chamada a serviço na
\neoidl{}} 
\label{lst:DBCPreCondServico}
\end{figure} 



\subsection{Pós-condição com chamada a serviço}
\label{Pos-condicao servico}

A pós-condição com chamada a serviço seguem a sequência de eventos indicada na
Figura \ref{FigServicePostcondition}. No caso da pós-condição, a execução do
serviço principal já ocoreu e a função do serviço na pós-condição é validar se a
execução do serviço principal ocorreu com sucesso. Algumas pós-condições são
naturais, como as que verificam se um objeto foi inserido após a operação de
inclusão (método \emph{POST}). Ou ainda, a que verifica se o objeto foi excluído
após uma operação \emph{DELETE}.

No exemplo da Figura \ref{lst:DBCPosCondServico}, o serviço principal faz a
exclusão de um objeto \textit{Order}. A pós-condição (linha 8) verifica, após o
processamento do \emph{DELETE}, se o objeto foi efetivamente apagado por meio do
serviço \emph{store.getOrder}. Se o serviço da pós-condição retornar o valor
\emph{HTTP Not Found}, o objeto foi adequadamente excluído. Caso contrário, o
serviço principal retornará o valor \emph{HTTP Not Modified}, o qual foi
estabelecido na instrução \textit{otherwise}.

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{trechos_codigo/store_pos_servico.neo}
\end{small}
\caption{Exemplo de notação de pós-condição com chamada a serviço na
\neoidl{}}
\label{lst:DBCPosCondServico}
\end{figure} 


\subsection{Sintaxe geral de pre e pós-condições}
\label{SintaxeGeralDbc}

Entre as subseções \ref{precondicaoBasica} e \ref{Pos-condicao servico} foram
apresentados exemplos simples de especificação de pre e condições na \neoidl{}
de modo separado, de modo a facilitar a compreensão. Esta subseção demonstra
a estruturação sintática das construções de \designbycontract{} agregadas
\neoidl{} por este trabalho.

Um módulo \neoidl{} possui uma seção para declaração dos serviços  

\center{\hilight{\texttt{Capacidade [\designbycontract{}]}}}





% (\texttt{<Type> <Ident> = 0;})
% \begin{tabbing}\tt
% ~\char36{}\char46{}\char47{}neoIDL\\
% \tt
% ~neoIDL\char58{}~panic\char33{}~\char40{}the~\char39{}impossible\char39{}~happened\char41{}\\
%\tt
% ~\char40{}GHC~version~7\char46{}6\char46{}3~for~x86\char95{}64\char45{}darwin\char41{}\char58{}\\
%\tt ~~Couldn\char39{}t~match~expected~type~\char96{}Plugin\char39{}\\
%\tt
% ~~~with~actual~type~\char96{}\char91{}GHC\char46{}Types\char46{}Char\char93{}\char39{}
%\end{tabbing}  

\subsection{Fontes de dados para pré e pós-condições}
\label{FonteDadosDbc}

\section{ESTUDO DE CASO: PLUGIN TWISTED}
\label{pluginTwisted}

\ldots

\subsection{Arquitetura}

% Diagrama da estrutura do código gerado


\subsection{Geração de código}

\section{ESTUDO EMPÍRICO DA ANÁLISE SUBJETIVA} 
\vspace{-6mm}

\label{analiseSubjetiva}
\vspace{-6mm}

%%%%
A language's expressiveness is the major criterion for choosing a language to
state a given set of facts: a language that cannot express the facts should not
be used. However, additional criteria are needed to choose among languages that
are sufficiently expressive  for a set of facts. Two of these criteria are how
ease it is to state the facts in the language and how easy is to perceive the
facts once they are stated.

expressividade de uma linguagem é o principal critério para a escolha de uma
linguagem para indicar um determinado conjunto de fatos: uma linguagem que não
podem expressar os fatos não devem ser usados. No entanto, os critérios
adicionais são necessários para escolher entre os idiomas que são
suficientemente expressivo para um conjunto de fatos. Dois desses critérios são
quão fácil é expor os fatos na linguagem e como é fácil de perceber os fatos,
uma vez que são demonstrados.

\cite{mackinlay1985expressiveness}

%%%%


%%%
Instead of aiming to be the best for solving any kind of
computing problem, DSLs aim to be particularly good for
solving a specific class of problems, and in doing so they
are often much more accessible to the general public than tra-
ditional programming languages.
\cite{taha2008domain}
%%%% 

%%%%
They offer substantial gains in expressiveness and ease of use compared
with GPLs in their domain of application’. [2] describes the typical costs of a
DSL, noting that a small extra initial investment in a DSL implementation typ-
ically leads to long term savings, in comparison to alternative routes.
\cite{tratt2008evolving}
%%%%

%%%%
A domain specific language (DSL) is a program-
ming language tailored for a particular application do-
main. Characteristic of an effective DSL is the ability
to develop complete application programs for a do-
main quickly and effectively. A DSL is not (neces-
sarily) “general purpose.” Rather, it should capture
precisely the semantics of an application domain, no
more and no less.

There are lots of advantages to using DSLs, start-
ing with the fact that programs are generally easier to
write, reason about, and modify compared to equivalent 
programs written in general purpose languages.
Indeed, these are the same advantages gained from using any high-level
programming language.
\cite{hudak1998modular}
%%%%




\subsection{Método}
\vspace{-6mm}

\subsection{GQM}
\vspace{-6mm}

\subsection{Questionário}
\vspace{-6mm}

\subsection{Análise dos Resultados}
\vspace{-6mm}


* Questionário montado para avaliar a utilidade de DbC com NeoIDL

* Inicialmente motivado pelo estudo do Alessandro Garcia

* GQM e Avaliação TAM

* Montagem do questionário

1. Perfil técnico-profissional do respondente
1.1 Para qual órgão ou empresa você presta serviços atualmente?
1.2 A quanto tempo você trabalha com desenvolvimento Web
1.3 A quanto tempo você desenvolve com uso de APIs Web (Web Service)
1.4 Qual o seu nível de experiência com especificação de API REST
1.5 Qual o seu nível de experiência com especificação de contratos com Swagger

3 Questões sobre especificação e implementação de APIs Web
3.1 A especificação do contrato formalmente, seja em Swagger ou NeoIDL, em
relação a descrição textual, aumentará meu nível de acerto na implementação (efetividade).
3.2 Identificar e compreender as operações e atributos na especificação Swagger
é simples para mim.
3.3 Identificar e compreender as operações e atributos na especificação NeoIDL é
simples para mim.

4. DbC
4.1 Conhecer previamente e explicitamente as precondições será útil para mim.
(Useful)
4.2 Aprender a identificar as precondições na NeoIDL parece ser simples pra mim
(Easy to learn)
4.3 Parece ser fácil para mim declarar uma precondição na NeoIDL
(Clear and understandable)
4.4 Me lembrar da sintaxe da precondição na NeoIDL é fácil  (Remember)

5. Geração de código
5.1 É claro e compreensível para mim o efeito da precondição sobre o código
gerado  (Controllable)
5.2 A geração do código de pré e pós-condições aumentará minha produtividade na
implementação do serviço (Job performance)
5.3 Assumindo ter a disposição a NeoIDL no meu trabalho, para especificação de
contratos e geração de código, eu presumo que a utilizarei regularmente no futuro.
5.4 Nesse mesmo contexto, eu vou preferir utilizar contratos escritos em NeoIDL
do que descritos de outra forma



* Distribuição do questionário

* Avaliação dos resultados

* Ameaças
- não foi fornecido nenhum material sobre a NeoIDL, apresentando somente o uma
descrição de serviço
- O questionário foi aplicado uma única vez, sem melhorias a partir do primeiro
conjunto de respostas


* Questionários futuros

A principal questão de pesquisa a ser avaliada com o uso do questionário é a utilidade em se agregar ao design das especificações de serviços REST as garantias de pré e
pós-condições. Em segundo momento, pressupondo a utilidade, avaliar se a NeoIDL
cumpre satisfatoriamente com este propósito, agregando à sintaxe da linguagem
a possibilidade de se expressar pré e pós-condições.

* Separar os respondentes em faixas de experiência. Verificar se as respostas
dos menos experientes precisam ser descartadas pela pouca capacidade crítica.
Separar a análise entre os respondentes que conhecem e os que não conhecem
Swagger.

* Perspectivas de comparação
a) Experiência com desenvolvimento com uso de REST
b) Experiência com Swagger
c) Utilidade da especificação formal de contratos
d) Percepção da NeoIDL sem DbC





