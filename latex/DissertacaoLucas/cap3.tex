\chapter{NEOIDL: LINGUAGEM PARA ESPECIFICAÇÃO DE CONTRATOS REST	}
\vspace{-6mm}


\section{APRESENTAÇÃO}
\label{apresentacaoNeoIDL}

A \neoidl{} é uma linguagem específica de domínio (\textit{Domain Specific
Language - DSL}) desenvolvida com o objetivo de possibilitar e simplificar o
processo de elaboração de contratos para serviços REST. Em seu projeto, foram
consideradas os requisitos de concisão, facilidade de compreensão humana,
extensibilidade e suporte à herança simples dos tipos de dados definidos pelo
usuário.

Além de ser um linguagem, a \neoidl{} é também um \textit{framework} de geração
de código, que permite, a partir de contratos especificados na linguagem, a geração
da implementação do serviço em várias linguagens e tecnologias, por meio de seus
\textit{pluggins}. As próximas subseções apresentam o histórico da \neoidl{},
sua sintaxe e \textit{framework}.


\subsection{Histórico e motivação}
\label{histMotivNeoIDL}
\vspace{-6mm}

A \neoidl{} surgiu no contexto de um projeto de colaboração entre a Universidade
de Brasília e o Exército Brasileiro. O projeto tinha os requisitos de modularidade,
com a lógica distribuída inclusive geograficamente, e de execução em plataformas
diversas. Diante dessa necessidade, o Exército desenvolveu um \textit{framework}
proprietário, voltado para arquitetura orientada a serviço e com suporte
a implantação de serviços REST em vários linguagens, chamado \neocortex{}.

A característica do \neocortex{} de se utilizar serviços implementados em vários
linguagens motivou o desenvolvimento um programa gerador de serviços poliglota
-- que produz código de várias linguagens de progração -- a partir da descrição
do contrato do serviço. Daí nasceu a \neoidl{}.

Entretanto, as linguagens de programação disponíveis para especificação de
contratos REST, como Swagger, WADL e RAML, tinham (e ainda tem) limitações
importantes para a abordagem desejada de se escrever primeiramente o contrato e,
a partir dele, gerar a implementação. Todas elas utilizam linguangens de
propósito geral (XML, JSON, YAML), tornando os contratos extensos e de difícil
compreensão por humanos. Além disso, não possuem mecanismos semânticos de
extensibilidade e modularidade.

Partiu-se então para o desenvolvimento de uma nova linguagem, com sintaxe
inspirada em linguagens mais claras e concisas -- CORBA IDL \cite{corba} e
Apache Thrift \cite{thrift} --, e que permitisse a declaração de tipos de
dados definidos pelo usuário e extensibilidade. Ambas,
CORBA e Apache Thrift, possuem limitações nesses últimos aspectos. A sintaxe e
as características da linguagem \neoidl{} são discutidas na subseção \ref{linguagemNeoIDL}.

Em relação à geração de código, dado o requisito de geração de código para
linguagens distintas, a \neoidl{} foi projetada para possui uma arquitetura
modular, de modo que novas linguagens ou características de implementaçao
pudessem se incorporadas por meio de \textit{plugins} da \neoidl{}. Assim, é
possível desenvolver um novo \textit{plugin} para geração de serviços em outras
linguagens, por exemplo PHP, sem alterar qualquer outro componente, conforme
apresentado na subseção \ref{frameNeoIDL}.

A primeira versão da \neoidl{}, ponto de onde partiu este trabalho, dava suporte
a geração de código em Java, Python e Swagger com as características necessárias
para execução no \neocortex{}. Foram desenvolvidos no decorrer do projeto nove
serviços do domínio de comando e controle \cite{david:commandControl},
compreendendo aproximadamente cinquenta módulos e geração de três mil linhas de
código Python a partir dos contrato especificados em \neoidl{} (contratos são
denominados \texttt{módulos} na \neoidl{}). Outros serviços foram implementados em Java. 



\subsection{\textit{Framework}}
\label{frameNeoIDL}
\vspace{-6mm}

A parte da \neoidl{} responsável pela geração de código de
serviço para as várias linguagens é chamada de \framework{} \neoidl{}. O núcleo do \framework{} é
composto de módulos responsáveis por fazer o \textit{parse} do contrato escrito
em \neoidl{}, por processar a especificação e pelo gerenciamento dos
\textit{plugins}. Já os \textit{plugins} extendem, cada um, a \neoidl{} para as
linguagens de destino. A figura \ref{fig:neoidl-architecture} ilustra a
arquitetura do \framework{}.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{neoidl.pdf}
\vspace{-.5cm}
\end{center}
\caption{Arquitetura do framework de geração de código da \neoidl{}.}
\label{fig:neoidl-architecture} 
\end{figure}


O núcleo do \framework{} possui um uma pequena aplicação que carrega as
definições dos \textit{plugins} e processa os argumentos da chamada do gerador
(o arquivo de contrato que terá o código gerado, o diretório de destino e a
linguagem a ser utilizada). O modo de funcionamento geral do \framework{} é
ilustrado na figura \ref{fig:programGenerator}. O \textit{parser} da \neoidl{}
foi construído utilizando \bnfc{} \cite{ranta-bnfc:2012} com a linguagem
funcional Haskell.

\begin{figure*}[bt]
\begin{center}
\includegraphics[scale=0.55,trim=0cm 1.5cm 0cm 0cm]{programgenerator.pdf}
\vspace{-.5cm}
\end{center}
\caption{Gerador de código da \neoidl{}}
\label{fig:programGenerator}
\end{figure*}

As próximas subseções detalham o funcionamento de dois módulos onde estão
contidas os principais trechos da lógica implementada na \neoidl{}: O
\textit{PluginDef} e \textit{PluginLoader}.


\subsubsection{Componente PluginDef}{\label{sec:plugindef}}

O desenvolvimento de \textit{plugins} na \neoidl{} devem obedecer algumas regras
de projeto estabelecidas no componente \texttt{PluginDef}, que é um módulo
escrito em Haskell. No \texttt{PluginDef} declara dois tipo de dados
(\texttt{Plugin} and \texttt{GeneratedFile}) e uma assinatura de tipo
(\texttt{Transform = Module -> [GeneratedFile]}). Eles definem uma família de
tipos que mapeiam um módulo \neoidl{} em uma lista de arquivos com o código
gerado ao final do processo.

De acordo com estas regras de projeto, cada \textit{plugin} precisa declarar uma
instância do tipo \texttt{Plugin} e implementar uma função de acordo com a
assinatura definida em \texttt{Transform}. Além disso, cada instância de  
\texttt{Plugin} precisa ter o nome \texttt{plugin} de forma que o componenente
\texttt{PluginLoader} possa obter os dados necessários para o seu processamento.
Assim, a execução de um \textit{plugin} consiste em aplicar sua função de
transformação correspondente a um módulo \neoidl{} e produzir uma lista de
arquivos de código fonte. 

\vspace{6mm}

\begin{figure}[h]
\begin{small}
\lstinputlisting[language=HaskellSimple,firstnumber=1]{pluginDefStructure.tex}
\vspace{-.5cm}
\end{small}
\caption{Assinatura do \texttt{PluginDef}}
\label{lst:pluginDef}
\end{figure}

\subsubsection{Componente PluginLoader}

O carregamento e validação dos \textit{plugins} são competências do componente
\texttt{PlutinLoader}. O primeito passo é listar todos os arquivos do diretório
do \textit{plugin} a ser carregado, filtrar os arquivos Haskell (extensão
\texttt{``.hs''}), criar um nome para um nome reservado (\textit{qualified
name}) para cada arquivo de \textit{plugin} e aplicar a função de compilação.

Caso todas as regras de definição do \textit{plugin} tenham sido atendidas, o
\textit{plugin} é carregado e estará pronto para ser acionado. Caso contrário,
algumas exceções podem ocorrer, como, por exemplo, não haver definição de
nenhum \textit{plugin} no arquivo:

\begin{tabbing}\tt
~\char36{}\char46{}\char47{}neoIDL\\
\tt ~neoIDL\char58{}~panic\char33{}~\char40{}the~\char39{}impossible\char39{}~happened\char41{}\\
\tt ~~\char40{}GHC~version~7\char46{}6\char46{}3~for~x86\char95{}64\char45{}darwin\char41{}\char58{}\\
\tt ~~~~Not~in~scope\char58{}~\char96{}Plugins\char46{}Python\char46{}plugin\char39{}
\end{tabbing}

Ou ainda em razão de o \textit{plugin} não ser uma instância do tipo
\texttt{Plugin}:

\begin{tabbing}\tt
~\char36{}\char46{}\char47{}neoIDL\\
\tt ~neoIDL\char58{}~panic\char33{}~\char40{}the~\char39{}impossible\char39{}~happened\char41{}\\
\tt ~\char40{}GHC~version~7\char46{}6\char46{}3~for~x86\char95{}64\char45{}darwin\char41{}\char58{}\\
\tt ~~Couldn\char39{}t~match~expected~type~\char96{}Plugin\char39{}\\
\tt ~~~with~actual~type~\char96{}\char91{}GHC\char46{}Types\char46{}Char\char93{}\char39{}
\end{tabbing}



\subsection{Linguagem}
\label{linguagemNeoIDL}
\vspace{-6mm}

A \neoidl{} simplifica a especificação de contratos REST pois possui uma sintaxe
concisa própria de linguagens de especificação de interfaces (\emph{interface
description languages}). Ademais, a \neoidl{} provê mecanismos de
modularização e herança, de forma que os contratos possam ser separados em
módulos \footnote{Os arquivos utilizados para definição de contratos
são denominados módulos na \neoidl{}}, facilitando a herança e manutenção dos
contratos.

Para demonstrar como os módulos são estruturados na
\neoidl{}, a seguir são apresentados alguns trechos de um serviço hipotético
de envio de mensagens. Na primeira parte, um módulo faz uma definição de tipo
de dado; em seguida, um segundo módulo, orientado a serviço, importa as
definições do primeiro para então declarar as especificações das operações do
serviço. Por fim, o módulo de serviço é acrescentado de uma anotação como
forma de extender as características da operação.

\vspace{6mm}

\begin{figure}[h]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{mensagemData.tex}
\vspace{-.5cm}
\end{small} 
\caption{Tipos de dados definidos na \neoidl}
\label{lst:messagedata-neo}
\end{figure}

O trecho ilustrado na figura \ref{lst:messagedata-neo} faz a definição de dois
tipos de dados. \emph{MessageType}, declarado no linha 2, é uma estrutura
simples do tipo enumeração. O outro tipo é \emph{Message}, declarado entre as
linhas 4 e 11, composto de seis atributos. O atributo \emph{type} de
\emph{Message} é do tipo \emph{MessageType} recém declarado.

Na \neoidl{} é utiliza a abordagem convenção sobre configuração, de modo que
todos os atributos declarados são obrigatórios, a menos que explicitamente
seja declarado diferente. O atributo \emph{subject} do tipo \emph{Message} é um
exemplo de atributo opcional (\texttt{<Type> <Ident> = 0;}).

O módulo seguinte (figura \ref{lst:sentmessage-neo}), na linha proposta pela
\neoidl{} para suporte a herança e reuso, importa o conjunto de definições de \emph{MessageData} e declara o
serviço \emph{sendbox} (linha 4), o qual possui duas capacidades. A
capacidade \emph{sendMessage} (linha 6) utiliza a operação \method{post} para submeter uma
mensagem (tipo \emph{Message}). A outra capacidade (linha 7) tem a finalidade de
listas as mensagens com um determinado sequecial, por meio da operação
\method{get}.

Por fim, a instrução \emph{path} indica o caminho (URI) onde as
operações serão disponibilizadas. Esse atribuito é importante para se definir
como as requisições serão roteadas entre os serviços.

\vspace{6mm}

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{mensagem.tex}
\end{small}
\caption{Sent message service specification in \neoidl}
\label{lst:sentmessage-neo}
\end{figure}

Ainda na filosofia de conversão sobre configuração, a \neoidl{} assume que os
argumentos das operações \method{POST} e \method{PUT} são enviadas no corpo da
requisição. Nas operações \method{GET} e \method{DELETE}, por outro lado,
presume-se que os agumentos estão contidos no \emph{path} da requisição ou ainda
como \textit{query string}.

A especificação dos contratos na \neoidl{} pode ser enriquecida com
anotações, por meio das quais se possibilita extender a semântica de uma
especificação sem que seja necessário alterar a sintaxe da \neoidl{}. Esse
recurso da \neoidl{} simplifica a inclusão de novas características aos
serviços, pois a alteração da sintaxe da própria \neoidl{} envolve um esfoço não
trivial de compatibilizar todos os \textit{plugins} já construídos.

O módulo apresentado na figura \ref{lst:annotationNeoIDL} contém, além das
informações contidas no módulo da figura \ref{lst:sentmessage-neo}, uma anotação chamada
\emph{Security Policy} (linhas 4 a 6) aplicada ao serviço \emph{sentbox}. A
declaração da anotação é feita no final do módulo (linhas 14 a 18).

\vspace{6mm}
 
\begin{figure}
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{messageSendAnnotation.tex}
\vspace{-.5cm}
\end{small}
\caption{Especificação de anotação na \neoidl{}}
\label{lst:annotationNeoIDL}
\end{figure}

Além de aplicáveis a \texttt{resources}, as anotações também podem ser aplicadas
a outros construtores da linguagem: \texttt{module}, \texttt{enum},
\texttt{entity}. Qualquer anotação na \neoidl{} possui a mesma estrutura: um
nome, um elemento alvo e uma lista propriedades. Todas estas informações ficam
disponíveis para utilização pelos \textit{plugins}.

As próxima subseções apresentam a estrutura sintática e léxica \neoidl{} e
refletem a situação de Agosto de 2015, antes da incorporação das construções
relativas a \designbycontract{} (estas informações foram geradas 
automaticamente pelo BNF-Converter \cite{forsberg-bnfc:2004} \textit{parser
generator}). 

\subsubsection{A estrutura léxica da \neoidl{}}\label{sub:lexico}

\begin{enumerate}
  \item Identificadores
  
  Identificadores \nonterminal{Ident} são literais (\textit{strings}) não
  delimitadas que começam com uma letra seguida por letras, números e os caracteres {\tt \_ '},
  exceto palavras reservadas.
  
  \item Literais
  
  Literais de texto são cadeias de caracteres  \nonterminal{String}\ com a forma
  \terminal{``}$x$\terminal{``}, onde $x$ é qualquer sequencia de caracter,
  exceto \terminal{``}, a menos que precedido por \text{\tt \char92{}}.
  
  Literais numéricos \nonterminal{Int}\ são sequências não vazias de números.
  
  Literais de ponto flutuantes \nonterminal{Double}\ tem a estrutura
  definida pela seguinte expressão regular: $\nonterminal{digit}+ \mbox{{\it
  `.'}} \nonterminal{digit}+ (\mbox{{\it `e'}} \mbox{{\it `-'}}?
  \nonterminal{digit}+)?$, ou seja, duas sequências de números separadas por um
  ponto, opcionalmente precedida de um símbolo de negativo.

  \item Palavras reservadas e símbolos

  O conjunto de palavras reservadas são os terminais da gramática da linguagem
  \neoidl{}. As palavras reservadas não compostas de letras são chamados
  símbolos, que são tratados de forma diferente dos identificadores. A
  sintaxe analisador léxico segue regras típicas de linguagens como Haskell, C e
  Java, incluindo correspondência mais longa e convenções para o espaço.
  
  As palavras reservadas utilizadas na \neoidl{} são as seguintes: \\

\begin{tabular}{lll}
{\reserved{annotation}} &{\reserved{call}} &{\reserved{entity}} \\
{\reserved{enum}} &{\reserved{extends}} &{\reserved{float}} \\
{\reserved{for}} &{\reserved{import}} &{\reserved{int}} \\
{\reserved{module}} &{\reserved{path}} &{\reserved{resource}} \\
{\reserved{string}} & & \\
\end{tabular}\\
  
Os símbolos utilizados na \neoidl{} são os seguintes: \\

\begin{tabular}{lll}
{\symb{\{}} &{\symb{\}}} &{\symb{;}} \\
{\symb{{$=$}}} &{\symb{.}} &{\symb{@}} \\
{\symb{(}} &{\symb{)}} &{\symb{0}} \\
{\symb{{$=$}{$=$}}} &{\symb{{$<$}{$>$}}} &{\symb{{$>$}}} \\
{\symb{{$>$}{$=$}}} &{\symb{{$<$}}} &{\symb{{$<$}{$=$}}} \\
{\symb{[}} &{\symb{]}} &{\symb{@get}} \\
{\symb{@post}} &{\symb{@put}} &{\symb{@delete}} \\
{\symb{/@require}} &{\symb{/@ensure}} &{\symb{/@invariant}} \\
{\symb{/@otherwise}} &{\symb{/**}} &{\symb{*/}} \\
{\symb{*}} &{\symb{@desc}} &{\symb{@param}} \\
{\symb{@consume}} &{\symb{,}} & \\
\end{tabular}\\

\end{enumerate}

\subsubsection{A estrutura sintática da NeoIDL}\label{sub:sintatico}

Não-terminais são delimitados entre $\langle$ e $\rangle$. O símbolo {\arrow}
(produto), {\delimit} (união) e {\emptyP} (regra vazia) advêm da notação BNF.
Todos os demais símbolos são terminais.\\

\begin{small}
\begin{tabular}{lll}
\label{lst:BNFnot}
{\nonterminal{Modulo}} {\arrow} {\terminal{module}} {\nonterminal{Ident}} {\terminal{\{}} \\ 
 \quad {\nonterminal{ListImport}} \\ 
 \quad {\nonterminal{MPath}} \\ 
 \quad {\nonterminal{ListEnum}} \\ 
 \quad {\nonterminal{ListEntity}} \\ 
 \quad {\nonterminal{ListResource}} \\ 
 \quad {\nonterminal{ListDecAnnotation}} \\ 
{\terminal{\}}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Import}} & {\arrow}  &{\terminal{import}} {\nonterminal{NImport}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{MPath}} & {\arrow}  &{\emptyP} \\
 & {\delimit}  &{\terminal{path}} {\terminal{{$=$}}} {\nonterminal{String}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{NImport}} & {\arrow}  &{\nonterminal{Ident}}  \\
 & {\delimit}  &{\nonterminal{Ident}} {\terminal{.}} {\nonterminal{NImport}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Entity}} & {\arrow}  &{\nonterminal{ListDefAnnotation}} {\terminal{entity}} {\nonterminal{Ident}} {\terminal{\{}} {\nonterminal{ListProperty}} {\terminal{\}}} {\terminal{;}}  \\
 & {\delimit}  &{\nonterminal{ListDefAnnotation}} {\terminal{entity}} {\nonterminal{Ident}} {\terminal{extends}} {\nonterminal{Ident}} {\terminal{\{}} {\nonterminal{ListProperty}} {\terminal{\}}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Enum}} & {\arrow}  &{\terminal{enum}} {\nonterminal{Ident}} {\terminal{\{}} {\nonterminal{ListValue}} {\terminal{\}}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{DecAnnotation}} & {\arrow}  &{\terminal{annotation}} {\nonterminal{Ident}} {\terminal{for}} {\nonterminal{AnnotationType}} {\terminal{\{}} {\nonterminal{ListProperty}} {\terminal{\}}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{DefAnnotation}} & {\arrow}  &{\terminal{@}} {\nonterminal{Ident}} {\terminal{(}} {\nonterminal{ListAssignment}} {\terminal{)}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Parameter}} & {\arrow}  &{\nonterminal{Type}} {\nonterminal{Ident}} {\nonterminal{Modifier}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Assignment}} & {\arrow}  &{\nonterminal{Ident}} {\terminal{{$=$}}} {\nonterminal{Value}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Modifier}} & {\arrow}  &{\emptyP} \\
 & {\delimit}  &{\terminal{{$=$}}} {\terminal{0}}  \\
\end{tabular}

\begin{tabular}{lllllllll}
{\nonterminal{AnnotationType}} & {\arrow}  &{\terminal{resource}}  
 & {\delimit}  &{\terminal{enum}}  
 & {\delimit}  &{\terminal{entity}}  
 & {\delimit}  &{\terminal{module}} 
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Resource}} & {\arrow}  &{\nonterminal{ListDefAnnotation}} {\terminal{resource}} {\nonterminal{Ident}} {\terminal{\{}} {\terminal{path}} {\terminal{{$=$}}} {\nonterminal{String}} {\terminal{;}} {\nonterminal{ListCapacity}} {\terminal{\}}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lll}
{\nonterminal{Capacity}} & {\arrow}  &{\nonterminal{NeoDoc}} {\nonterminal{ListDefNAnnotation}} {\nonterminal{Method}} {\nonterminal{Type}} {\nonterminal{Ident}} {\terminal{(}} {\nonterminal{ListParameter}} {\terminal{)}} {\terminal{;}}  \\
\end{tabular}

\begin{tabular}{lllllllll}
{\nonterminal{Method}} & {\arrow}  &{\terminal{@get}} 
 & {\delimit}  &{\terminal{@post}} 
 & {\delimit}  &{\terminal{@put}}  
 & {\delimit}  &{\terminal{@delete}} 
\end{tabular}\\
\end{small}    



\section{AVALIAÇÃO EMPÍRICA}
\vspace{-6mm}

A primeira versão da \neoidl{} foi submetida a uma avaliação empírica de sua
expressividade e reuso em um contexto real. As próximas subseções apresentam 
o resultado da análise comparativa da representação de 44 (quarenta e quatro)
contratos escritos em Swagger em relação à mesma especificação em \neoidl{}.
Esse estudo foi realizado no transcurso do trabalho de mestrado e 
publicado no periódico IJSeke \cite{lima2015neoidl}.

\subsection{Expressividade}
\vspace{-6mm}

A \neoidl{} é uma DSL, conforme apresentado na seção \ref{apresentacaoNeoIDL},
e como tal se destina a atender a um propósito específico, nem mais, nem menos
\cite{hudak1998modular}. A \neoidl{} foi projetada para permitir a
especificação de contratos de serviços REST de forma mais expressiva e concisa,
facilitando-se a escrita e leitura por humanos (mais detalhes na subseção
\ref{histMotivNeoIDL}).

Programas escritos em DSLs costumam ser mais fáceis de escrever e,
consequentemente, mais fáceis de se manter comparavelmente a programas escritos
em linguagens de propósito geral \cite{hudak1998modular}. Isso se deve
justamente ao fato de a DSL tratar apenas um conjunto reduzido de situações e
problemas, fazendo com ela seja, muitas vezes, mais acessível ao público geral
\cite{taha2008domain}.

A expressividade é um dos principais critérios para se escolher uma
linguagem. Entretanto a linguagem que não expressa todas as situações
necessárias ao seu contexto de uso, por óbvio, não podem ser usadas
\cite{mackinlay1985expressiveness}. Nesse sentido, o primeiro teste que a
\neoidl{} passou foi a produção de contratos e serviços reais no início do
projeto com o Exército Brasileiro (vide subseção \ref{histMotivNeoIDL}).

Assim, tendo a \neoidl{} demonstrado sua capacidade de representar contratos
REST, foi realizada uma segunda análise: quão expressiva seria a \neoidl{}
em comparação com outra linguagem com o mesmo objetivo. Foi escolhida
Swagger \cite{swaggerSite}, uma linguagem cujo uso tem crescido pela indústria.
Em Swagger, os contratos são escritos em JSON\cite{JSon} ou YAML\cite{YAML},
ambos com uma estrutura geral de chave-valor.

Tendo sido a \neoidl{} desenvolvida para ser mais fácil de compreender e
manipular por humanos, foi adotada a estratégia de comparar a expressividade em
termos de quantidade de linhas de código (SLOC - do inglês \textit{Source Lines of Code}), uma vez que
muitas linhas significam maior esforço para escrita, sobretudo na abordagem
\CtFirst{}. 









In a collaborative work with the Brazilian Army,
we obtained a portion of their contracts' specifications in Swagger (44 in total), specified with version 1.2.
Our first step was to rewrite these specifications in \neoidl{} and thus compare the total
number of lines of code (which might serve as a metric of expressiveness).
The 44 contracts in Swagger amount to 13921 lines of specification, while the same set of contracts in NeoIDL comprises 5140 lines of specification. Thus, the average reduction was about 63\%. In others words, it means that 10 lines of structured Swagger specification require
about 4 lines of \neoidl{} specification. In this analysis we only considered \emph{physical lines of code}, ignoring 
blank lines and lines consisting of delimiters only. The Appendix A shows a sample contract we analised.

The reduction in number of lines is not the same in all contracts. For instance, a given service\footnote{For confidentiality reasons, the real names of contracts were omitted.} required 367 lines of Swagger specification and 112 lines of \neoidl{} specification. This case  
represents a reduction of about 69\%. On the other hand, another service contract required 
81 lines of specification in Swagger and 42 lines of \neoidl{} specification. In this case, the SLOC decrease was slightly less than 50\%.

The size of the original contract has only a small influence in the observed expressiveness. 
Therefore, we cannot assume that \emph{the bigger the contract is in Swagger 
the bigger is the improvement (with respect to the smaller specification size) of \neoidl}. We 
also realized that the use of a more descritive documentation, the number of entities, and the number of capacities do not correlate to the advantageous reduction of lines of code during a 
transformation of Swagger specifications into \neoidl{} specifications. Therefore, it seems that 
the benefits do not relate to the size of the original specifications.  
Table~\ref{tab:size-corr} presents the correlation between the improvement of 
expressiveness (measured as the percentage of reduction obtained 
after transforming Swagger specifications into \neoidl{} specifications) and 
some metrics related to the size of the original Swagger specifications.

\begin{table}[htb]
\caption{Correlation of the Expressiveness Improvement with the size of the Swagger specifications}
\begin{center}
\begin{tabular}{lrr} 
\toprule
Metric & Pearson's correlation & \emph{p-value} \\ \hline \hline 
LOC of Swagger specification & 0.19 &  0.20 \\ 
Number of services & 0.14 & 0.35 \\ 
Number of capacities & 0.14 & 0.34 \\
Number of entities & 0.20 & 0.18 \\ \bottomrule 
\end{tabular} 
\end{center}
\label{tab:size-corr}
\end{table}





\subsection{Potencial de reuso}



Similar to \neoidl{}, Swagger presents 
some mechanisms to reuse user defined structures. Nevertheless, 
this feature is almost ignored in the set of contracts we analysed, which 
leads to the duplication of entities' definition across different 
Swagger specifications. This might have occurred either due to the 
nonintuitive construct for reusing definitions in Swagger (based on 
references to JSON files) and the difficulties to identify 
that one entity had already been specified in another contract.
After analysing the 44 Swagger specifications, we realized that 40 entities 
have been specified in  more than one contract. Actually, one specific 
entity is present in 12 distinct Swagger contracts. 




 
\section{EXTENSÃO DA NEOIDL PARA DESIGN BY CONTRACT}

Influência de Eiffel, JML e Spec\#

Eiffel assertions are Boolean expressions, with a few extensions such as the old
notation. Since the whole power of Boolean expressions is available, they may
include function calls. Because the full power of the language is available to
write these functions, the conditions they express can be quite sophisticated.
\cite{meyer1992applying}

 
 
\subsection{Proposta: Serviços com Desing-by-Contract}
\vspace{-6mm}

Os benefícios esperados pela adoção da arquitetura orientada a serviços
somente serão auferidos com a concepção adequada de cada serviço. 
Por essa razão, é necessário planejar o projeto dos serviços criteriosamente
antes de lançar mão do desenvolvimento, com preocupação especial em garantir
um nível aceitável de estabilidade aos consumidores de cada serviço.
Nessa etapa do projeto de desenho da solução, a especificação do contrato do
serviço (Web API) exerce uma função fundamental. 

Na sociedade civil, contratos são meios de se formalizar acordo entre partes a
fim de definir os direitos e deveres de cada parte e buscar atingir o
objetivo esperado dentro de determinadas regras. Cada parte espera que as outras
cumpram com suas obrigações.
Por outro lado, sabe-se que o descumprimeto das obrigações costuma implicar de
penalizações até o desfazimento do contrato. 

Contratos entre serviços Web seguem em uma linha análoga. O desenho das
capacidades (operações) e dos dados das mensagens correspondem aos
termos do contrato no sentido do que o consumidor deve esperar do serviço
provedor. Porém identificou-se, após ampla pesquisa realizada sobre o tema, que
as linguagens disponíves para especificação de contratos atingem apenas esse
nível de garantias. No contexto de webservices em REST, conforme descrito na
seção \ref{secaoREST}, há ainda a ausência de padrão para especificação
contratos, tal como ocorre com o WSDL adotado em SOAP.

A proposta deste trabalho é extender os níveis de garantias, de modo a promover
um patamar adicional com obrigações mutuas entre os serviços (consumidor e
provedor). Isso se dá para adoção do conceito de Design-by-Contract (debatido
na seção \ref{Design-by-Contract}) em que a execução da
capacidade do serviço garantirá a execução, desde que satisfeitas as condições
prévias. O detalhamento do processo é exposto nas seções que se seguem.

\vspace{-6mm}

\subsubsection{Modelo de operação}
\vspace{-6mm}

As garantias para execução dos serviços são estabelecidas em duas etapas: pré- e
pós-condições. Nas pré-condições o provedor do serviço estabelece os requisitos
para que o serviço possa ser executado. A etapa de pós-condições tem o papel de
validar se a mensagem de retorno do serviço possui resultados válidos.

O diagrama da Figura \ref{FigServiceDbC} descreve como ocorre a operação das
pré- e pós-condições. O processo se inicia com a chamada à capacidade do serviço e a
identificação da existência de uma pré-condição. Caso tenham sido estabelecidas 
pré-condições, essas são avaliadas. Caso alguma delas não tenham sido
satisfeitas, o serviço principal não é processado e o provedor do serviço
retornar o código de falha definido no contrato correspondente.


\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm 0mm,clip]{ServiceDbC.png}
\caption{Digrama de atividades com verificação de pré e pós condições}
\label{FigServiceDbC}
\end{figure}

Caso tenham sido definidas pós-condições, essas são acionadas após o
processamento da capacidade, porém antes do retorno ao consumidor do serviço.
Assim, conforme Figura \ref{FigServiceDbC}, visando não entregar ao cliente uma
mensagem ou situação incoerente, as pós-condições são validadas. Caso todas as
pós-condições tenham sido satisfeitas, a mensagem de retorno é encaminhada ao
cliente. Caso contrário, será retornado o código de falha.


\vspace{-6mm}


\subsubsection{Verificação das pré-condições}
\vspace{-6mm}

As pré-condições podem ser do tipo baseado nos parâmetros da requisição ou do
tipo baseado na chamada a outro serviço. Denominamos, para o contexto desta
dissertação, de básica a pré-condição baseada apenas nos parâmetros da
requisição (atributos da chamada ao serviço). Nessa validação é direta,
comparando os valores passados com os valores admitidos. 

No caso das pré-condições baseadas em serviços, é realizada chamada a outro
serviço para verificar se uma determinada condição é satisfeita. Este modo de
funcionamento, que se assemelha a uma composição de serviço, é mais versátil, pois permite
validações de condições complexas sem que a lógica associada seja conhecida pelo
cliente. Assim, os contratos que estabelecem esse tipo de
pré-condição se mantem simples.

A Figura \ref{FigServicePrecondition} detalha as etapas de verificação de cada
pré-condição. Nota-se que a saída para as situações de desatendimento às
pré-condições, independentemente do tipo, é o mesmo. O objetivo desta abordagem
é simplificar o tratametno de exceção no consumidor.

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm 0mm,clip]{PreconditionValidation.png}
\caption{Diagrama de atividades do processamento da pré-condição}
\label{FigServicePrecondition}
\end{figure}


\subsubsection{Verificação das pós-condições}
\vspace{-6mm}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth,trim = 0mm 5mm 0mm
0mm,clip]{PostconditionValidation.png} 
\vspace{-6mm}
\caption{Diagrama de atividades do processamento da pós-condição}
\label{FigServicePostcondition}
\end{figure}

A verificação das pós-condições acontece de modo muito similar a das
pré-condições. Há também os dois tipos, baseado em valores e em chamadas a
outros serviços. O diferencial está em que a validação dos valores passa a
ocorrer a partir dos valores contidos na mensagem de retorno. A Figura
\ref{FigServicePostcondition} descreve as etapas necessárias para validação de
cada pré-condição.

	
	
	
	

\subsection{Extensão da linguagem}

\subsubsection{Precondição básica}

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{DBCsimple.neo}
\end{small}
\caption{Exemplo da notação DBC básica na \neoidl{}}
\label{lst:DBCService}
\end{figure} 

\subsubsection{Pós-condição básica}

\ldots



\subsubsection{Precondição com chamada a serviço}

\begin{figure}[htb]
\begin{small}
\lstinputlisting[language=NeoIDL,firstnumber=1]{DBCservice.neo}
\end{small}
\caption{Exemplo da notação DBC na \neoidl{} com chamada a serviço}
\label{lst:DBCService}
\end{figure} 


\subsubsection{Pós-condição com chamada a serviço}

\ldots

\subsection{Estudo de caso: plugin twisted}

\ldots

\subsubsection{Arquitetura}

% Diagrama da estrutura do código gerado


\subsubsection{Geração de código}